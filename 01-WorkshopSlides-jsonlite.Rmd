---
title: "Workshop 1: Working with JSON & jsonlite"
author: "[Sangeeth Selvaraju](https://github.com/RajaSangeeth) & [Milan Schr√∂der](https://github.com/milanschroeder)"
institute: "Hertie School | [Intro to Data Science Workshop](https://github.com/intro-to-data-science-21-workshop)"
output: 
  xaringan::moon_reader:
    ioslides_presentation:
      incremental: true
      self_contained: true
      widescreen: true
      smaller: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      eval = TRUE,
                      error = FALSE,
                      message = FALSE,
                      warning = FALSE,
                      comment = " ",
                      prompt = TRUE,
                      fig.align="center", #fig.width=6, fig.height=4.5, 
                      # out.width="748px", #out.length="520.75px",
                      dpi=300, #fig.path='Figs/',
                      cache=F, #echo=F, warning=F, message=F
                      engine.opts = list(bash = "-l"))

library(pacman)
p_load(xaringan, jsonlite, tidyverse)
```

# Intro

## 1st slide
- What is JSON?
- JavaScript Object Notation: Is a standard open file format and data interchange format that uses human readable text to store and transmit data objects.
- It is a common data format with diverse uses particularly in electronic data interchange like web applications with servers


- History of the package
- Douglas Crockford originally specified the JSON format in the early 2000's
- He popularized it with Chip Morningstar and with State Software who helped in the early stages of the development 
- It was eventually sold to Sun Microsystems, Amazon, EDS. The JSON.org site went live in 2002 and Yahoo started offering some of their web services in JSON
- Fun fact: Crockford added a clause in the JSON license stating that "The software shall we used for Good and not evil" in order to open source it and mock corporate lawyers. 

---
#Intro
## 2nd slide
- Benefits of using JSON
- JSON is the superior version of XML
- It has easy syntax
- It's supported across many browsers so it is compatible with many browsers
Most importantly for us: JSON is a great tool for sharing data of any size, even audio or videos as it stores the data in arrays

- Where is it used?
- It is mostly used in web API's and for web development 

---
# Data Structures in JSON

- object
  - unordered list of key : value pairs
  - similar to a dictionary
  - can include all types of JSON structures
  
  
- array
  - ordered sequence of values
  - similar to R's vector-class
  - datatype can be heterogeneous


- value
  - no direct representation in R
  - one-element values are similar to vectors of length 1
  - but they can also consist of multiple elements

---
# object
<img src="https://www.json.org/img/object.png" height=440>
---
# array
<img src="https://www.json.org/img/array.png" heght=440>
---
# value
<img src="https://www.json.org/img/value.png" heght=440>

---

# Key functions: `fromJSON`

```{r fromJSONarray}
JSON_array <- '[1, true, null, "string"]'
fromJSON(JSON_array)
```


```{r fromJSONvalue}
JSON_object <- 
'[
{"key": "value", "one": 1, "any_questions?": false},
{"key": null, "one": "NA", "any_questions?": true}
]'
fromJSON(JSON_object)
```

---

# Key functions: `toJSON`

```{r toJSON}
starwars %>% slice_sample(n = 1) %>% 
  toJSON(pretty = T)
```

---

## Potential Issues: Dealing with NAs

R knows different `NA`-values, but JSON only has `null` to represent those...

- By default, `NA`'s are treated as strings (in numeric vectors)
  - so the string is no longer homogeneous, cause errors in statistical operations
  - but all information is preserved 
  
```{r}
(toJSON(c(3.14, NA, NaN, 42, Inf, -Inf)))
```
  
- You can choose to represent them as null
  - keeping the vector numeric
  - but loosing information

```{r}
(toJSON(c(3.14, NA, NaN, 42, Inf, -Inf), na = "null"))

```



---

## Potential Issues: Converting back and forth

- Note that there is no guaranteed one-to-one correspondence of R and JSON objects:
  - it will still be the encoded data
  - but ordering, class, etc. may differ

```{r}
(example <- slice_sample(starwars[1:5], n = 2))
fromJSON(toJSON(example[1:5]))
```

---

## Two more functions from the package:

if you - for whatever reason - need it to be consistent, use `(un)serializeJSON` instead

```{r}
unserializeJSON(serializeJSON(example[1:5]))
```



This allows you to convert back and get the exact same structure back...

---

## Two more functions from the package:

...But it comes with a downside: 
The JSON structure has to be much harder to read (or transfer to other languages), to perfectly resemble the original...

```{r}
serializeJSON(example, pretty = TRUE)
```


